<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Тестирование знаний — fixed parser</title>
<style>
:root{--bg:#07101a;--panel:rgba(18,24,33,0.56);--accent1:#45a8ff;--accent2:#2aa1ff;--muted:#98a0b3;--text:#e6eef8}
.light{--bg:#f5f7fb;--panel:rgba(255,255,255,0.92);--text:#081026;--muted:#52606d}
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial;color:var(--text);background:linear-gradient(180deg,var(--bg), #061018)}
.container{max-width:1100px;margin:28px auto;padding:18px}
.header{display:flex;align-items:center;justify-content:space-between;padding:12px;border-radius:14px;background:var(--panel)}
.title{font-weight:800;font-size:22px}
.subtitle{color:var(--muted);font-size:13px}
.card{margin-top:16px;padding:20px;border-radius:16px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01))}
.progress-row{display:flex;align-items:center;gap:12px;margin-bottom:16px}
.progress-small{font-size:13px;color:var(--muted);min-width:180px}
.progress-track{flex:1;height:8px;background:rgba(255,255,255,0.03);border-radius:999px;overflow:hidden}
.progress-bar{height:100%;width:0%;background:linear-gradient(90deg,var(--accent1),var(--accent2));transition:width .35s ease}
.question{font-size:20px;font-weight:700;margin-bottom:12px}
.options{display:flex;flex-direction:column;gap:10px}
.option{display:flex;align-items:center;gap:14px;padding:14px;border-radius:12px;background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);cursor:pointer}
.option .opt-text{flex:1}
.meta{display:flex;align-items:center;justify-content:space-between;margin-top:12px}
.feedback{padding:10px 12px;border-radius:10px;display:none;font-weight:700}
.feedback.correct{background:rgba(46,204,113,0.12);color:#2ecc71}
.feedback.incorrect{background:rgba(255,107,107,0.12);color:#ff6b6b}
.nav{display:flex;align-items:center;gap:12px;justify-content:flex-end;margin-top:18px}
.btn{padding:10px 16px;border-radius:12px;border:none;background:var(--accent1);color:white;font-weight:700;cursor:pointer}
.btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04)}
.btn.danger{background:linear-gradient(90deg,#ff4757,#ff3838)}
.start-modal{position:fixed;inset:0;background:linear-gradient(rgba(3,6,10,0.6), rgba(3,6,10,0.6));display:flex;align-items:center;justify-content:center;z-index:2000}
.start-card{background:var(--panel);padding:22px;border-radius:14px;width:720px;box-shadow:0 12px 30px rgba(2,6,23,0.6);color:var(--text);text-align:left}
.small{color:var(--muted);font-size:13px}
.debug-panel{margin-top:12px;padding:10px;border-radius:8px;background:rgba(255,255,255,0.02);color:var(--muted);font-size:13px}
pre.sample{background:rgba(0,0,0,0.06);padding:8px;border-radius:6px;overflow:auto;max-height:120px}
</style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div>
        <div class="title" id="testTitle">Тестирование знаний</div>
        <div class="subtitle" id="testSubtitle">Выберите режим тестирования</div>
      </div>
      <div>
        <button id="themeBtn" class="btn.ghost">Тема</button>
      </div>
    </div>

    <div class="card">
      <div class="progress-row">
        <div class="progress-small" id="psmall">Вопрос 1 из N</div>
        <div class="progress-track"><div id="progressBar" class="progress-bar"></div></div>
        <div class="progress-pct" id="ppct">0%</div>
      </div>

      <div>
        <div class="question" id="qtext">Загрузка...</div>
        <div class="options" id="options"></div>

        <div class="meta">
          <div id="feedback" class="feedback"></div>
          <div id="explain" class="small" style="display:none"></div>
        </div>
      </div>

      <div class="nav">
        <button id="prevBtn" class="btn ghost">Назад</button>
        <button id="actionBtn" class="btn">Следующий</button>
      </div>
    </div>

    <div id="debug" class="debug-panel" style="display:none">
      <div><strong>Parser debug:</strong></div>
      <div>Blocks found: <span id="dbgBlocks">0</span></div>
      <div>Questions parsed: <span id="dbgQuestions">0</span></div>
      <div style="margin-top:8px">Если вопросов 0 — внизу показывается фрагмент файла:</div>
      <pre id="dbgSample" class="sample"></pre>
    </div>
  </div>

  <div class="start-modal" id="startModal">
    <div class="start-card">
      <h2>Тестирование — выбор режима</h2>
      <p class="small">Вопросы загружаются из <code>questions.txt</code>. Поддерживаем формат: номер + варианты в строках вида <code>[ ]</code> / <code>[x]</code> (латинская или русская x).</p>
      <div style="display:flex;gap:8px;margin-top:12px;">
        <button id="singleBtn" class="btn">Пройти один раз</button>
        <button id="masteryBtn" class="btn ghost">Mastery (повторять неверные)</button>
      </div>

      <div style="margin-top:12px;" class="small">
        <div>Пример (в файле):</div>
        <pre class="sample">117. ...  
[ ] Вариант 1  
[x] Вариант 2  
[ ] Вариант 3</pre>
        <div style="margin-top:8px;color:var(--muted)">Если парсер не найдёт вопросов — в панели отладки будет показан фрагмент файла для диагностики.</div>
      </div>
    </div>
  </div>

<script>
/* ======= GLOBAL ======= */
let mode = 'single';
let currentQuestions = [];
let order = [];
let currentIndex = 0;
let score = 0;
let answered = false;
let userSelections = {};
let totalQuestionsInTest = 0;
let questionsAnswered = 0;

/* ======= DOM ======= */
const qtext = document.getElementById('qtext');
const optionsEl = document.getElementById('options');
const actionBtn = document.getElementById('actionBtn');
const prevBtn = document.getElementById('prevBtn');
const progressBar = document.getElementById('progressBar');
const psmall = document.getElementById('psmall');
const ppct = document.getElementById('ppct');
const feedbackEl = document.getElementById('feedback');
const startModal = document.getElementById('startModal');
const singleBtn = document.getElementById('singleBtn');
const masteryBtn = document.getElementById('masteryBtn');
const debugPanel = document.getElementById('debug');
const dbgBlocks = document.getElementById('dbgBlocks');
const dbgQuestions = document.getElementById('dbgQuestions');
const dbgSample = document.getElementById('dbgSample');

/* ======= helpers ======= */
function shuffleInPlace(a){ for(let i = a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];} return a;}
function shuffled(a){ return shuffleInPlace(a.slice()); }
function isMulti(q){ return Array.isArray(q.correctAnswers) && q.correctAnswers.length>1; }

/* ======= LOAD ======= */
async function loadQuestionsFromFile() {
  try {
    const resp = await fetch('questions.txt');
    if (!resp.ok) throw new Error('fetch not ok');
    const txt = await resp.text();
    const qs = parseQuestions(txt);
    // debug info
    dbgBlocks.textContent = window._parser_blocks_count || 0;
    dbgQuestions.textContent = qs.length;
    if (qs.length === 0) {
      debugPanel.style.display = 'block';
      dbgSample.textContent = txt.slice(0, 2000);
    } else {
      debugPanel.style.display = 'none';
    }
    return qs;
  } catch (e) {
    console.error('loadQuestionsFromFile error', e);
    alert('Не удалось загрузить questions.txt — проверьте путь и наличие файла рядом с html.');
    return [];
  }
}

/* ======= ROBUST PARSER =======
- поддерживает номера с пробелами перед ними
- ищет первую опцию в блоке, затем собирает все строки с [ ] / [x]
- игнорирует шум после опций
- возвращает массив вопросов с question, questionNumber, options[], correctAnswers[]
*/
function parseQuestions(text){
  if (!text) return [];

  // Убираем BOM и нормализуем
  const withoutBOM = text.replace(/^\uFEFF/, '');
  const normalized = withoutBOM.replace(/\r\n/g,'\n').replace(/\r/g,'\n');

  // Блоки: начиная с "число." до следующего "число." или до конца
  // допускаем пробелы в начале строки перед номером
  const blockRegex = /(^\s*\d+\.\s[\s\S]*?)(?=(?:^\s*\d+\.)|\s*$)/gim;
  const blocks = [];
  let m;
  while ((m = blockRegex.exec(normalized)) !== null){
    blocks.push(m[1].trim());
  }
  // сохраняем для debug
  window._parser_blocks_count = blocks.length;

  const questions = [];
  // шаблоны для опций
  const firstOptionLocator = /(^|\n)\s*\[\s*[xXхХ]?\s*\]/m;
  const optionLinePattern = /^\s*\[\s*([xXхХ]?)\s*\]\s*(.*)$/;

  for (let bi=0; bi<blocks.length; bi++){
    const block = blocks[bi];

    // найти первую опцию
    const optLoc = firstOptionLocator.exec(block);
    if (!optLoc) {
      // нет опций — пропускаем (возможный шум)
      continue;
    }
    const optPos = optLoc.index + (optLoc[1] ? optLoc[1].length : 0);

    // вопрос — всё до первой опции
    let rawQuestion = block.substring(0, optPos).replace(/^\s*\d+\.\s*/, '').trim();
    // если вопрос пустой — попытаемся взять первую строку блока
    if (!rawQuestion) {
      const firstLine = block.split('\n')[0] || '';
      rawQuestion = firstLine.replace(/^\s*\d+\.\s*/, '').trim();
    }

    // варианты — всё от optPos до конца блока, но берем только строки, которые соответствуют шаблону опции
    const tail = block.substring(optPos).trim();
    const lines = tail.split('\n').map(l => l.trim());
    const options = [];
    const correctAnswers = [];

    for (let li=0; li<lines.length; li++){
      const line = lines[li];
      const om = line.match(optionLinePattern);
      if (om){
        const mark = om[1];
        const txt = om[2].trim().replace(/\s+$/, '');
        // иногда в строке варианты идут в одну строку с номером следующего вопроса — обрезаем случайную "NNN." в конце
        const txtClean = txt.replace(/\s*\d+\.\s*$/,'').trim();
        options.push(txtClean);
        if (/[xXхХ]/.test(mark)) {
          correctAnswers.push(options.length - 1);
        }
      } else {
        // строка не выглядит как опция — пропускаем. (в сложных случаях можно агрегировать как продолжение предыдущего варианта)
        // Если предыдущая строка была опцией, и текущая строка не начинается с '[' — считаем её продолжением текста предыдущей опции
        if (options.length > 0 && !lines[li].startsWith('[')) {
          // склеиваем с предыдущим вариантом
          const prev = options.pop();
          const joined = (prev + ' ' + line).trim();
          options.push(joined);
        }
      }
    }

    if (options.length === 0) continue;

    // номер вопроса
    const numMatch = block.match(/^\s*(\d+)\./);
    const qnum = numMatch ? parseInt(numMatch[1],10) : (questions.length+1);

    questions.push({
      question: rawQuestion || `Вопрос ${questions.length+1}`,
      questionNumber: qnum,
      options,
      correctAnswers,
      explanation: ''
    });
  }

  return questions;
}

/* ======= SESSION / RENDER ======= */
function saveState(){
  const s = {mode, order, currentIndex, score, userSelections, totalQuestionsInTest, questionsAnswered};
  localStorage.setItem('testState', JSON.stringify(s));
}
function loadState(){
  try { return JSON.parse(localStorage.getItem('testState')); } catch(e){ return null; }
}
function clearState(){ localStorage.removeItem('testState'); }

async function startSession(selMode, savedState=null){
  mode = selMode;
  startModal.style.display = 'none';
  qtext.textContent = 'Загрузка вопросов...';
  optionsEl.innerHTML = '';
  const qs = await loadQuestionsFromFile();
  if (!qs || qs.length === 0){
    qtext.textContent = 'Вопросы не найдены — см. панель отладки';
    return;
  }
  currentQuestions = qs;
  totalQuestionsInTest = currentQuestions.length;
  if (savedState){
    order = savedState.order;
    currentIndex = savedState.currentIndex;
    score = savedState.score;
    userSelections = savedState.userSelections || {};
    questionsAnswered = savedState.questionsAnswered || 0;
  } else {
    order = shuffled(Array.from({length: currentQuestions.length}, (_,i)=>i));
    currentIndex = 0; score = 0; userSelections={}; questionsAnswered=0;
  }
  renderCurrent();
  saveState();
}

function renderCurrent(){
  if (currentIndex >= order.length) { showResults(); return; }
  const qidx = order[currentIndex];
  const q = currentQuestions[qidx];
  qtext.textContent = q.question;
  optionsEl.innerHTML = '';
  feedbackEl.style.display = 'none';

  const pairs = q.options.map((t,i)=>({t,orig:i}));
  shuffleInPlace(pairs);

  const multi = isMulti(q);
  pairs.forEach(pair=>{
    const label = document.createElement('label');
    label.className='option';
    const input = document.createElement('input');
    input.type = multi ? 'checkbox' : 'radio';
    input.name = 'opt'+qidx;
    input.dataset.orig = String(pair.orig);
    const span = document.createElement('span');
    span.className = 'opt-text';
    span.textContent = pair.t;
    label.appendChild(input); label.appendChild(span);
    optionsEl.appendChild(label);
    if (!multi){
      label.addEventListener('click', ()=>{
        if (answered) return;
        const chosen = Number(input.dataset.orig);
        userSelections[qidx] = [chosen];
        evaluateSingle(qidx, chosen);
      });
    }
  });

  prevBtn.disabled = currentIndex === 0;
  actionBtn.disabled = true;
  if (multi){
    actionBtn.textContent = 'Продолжить';
    optionsEl.querySelectorAll('input').forEach(inp=>inp.addEventListener('change', ()=> {
      actionBtn.disabled = optionsEl.querySelectorAll('input:checked').length === 0;
    }));
  } else {
    actionBtn.textContent = (mode==='single' && currentIndex===order.length-1) ? 'Завершить' : 'Следующий';
  }

  psmall.textContent = `Вопрос ${currentQuestions[qidx].questionNumber} из ${totalQuestionsInTest}`;
  const pct = Math.round(((currentIndex+1)/order.length)*100);
  progressBar.style.width = pct+'%';
  ppct.textContent = pct+'%';
  answered = false;
  saveState();
}

function evaluateSingle(qidx, chosenOrig){
  const q = currentQuestions[qidx];
  const correct = q.correctAnswers.includes(chosenOrig);
  optionsEl.querySelectorAll('.option').forEach(label=>{
    label.style.pointerEvents='none';
    const orig = Number(label.querySelector('input').dataset.orig);
    label.classList.remove('correct','incorrect','selected');
    if (q.correctAnswers.includes(orig)) label.classList.add('correct');
    if (orig===chosenOrig && !correct) label.classList.add('incorrect');
    if (orig===chosenOrig) label.classList.add('selected');
  });
  feedbackEl.textContent = correct ? '✓ Правильно' : '✗ Неправильно';
  feedbackEl.className = 'feedback ' + (correct ? 'correct' : 'incorrect');
  feedbackEl.style.display = 'block';
  if (correct) score++;
  answered = true;
  questionsAnswered++;
  actionBtn.disabled = false;
}

function evaluateMulti(qidx){
  const q = currentQuestions[qidx];
  const chosen = Array.from(optionsEl.querySelectorAll('input:checked')).map(i=>Number(i.dataset.orig)).sort((a,b)=>a-b);
  const corr = q.correctAnswers.slice().sort((a,b)=>a-b);
  const full = JSON.stringify(chosen)===JSON.stringify(corr);
  optionsEl.querySelectorAll('.option').forEach(label=>{
    label.style.pointerEvents='none';
    const orig = Number(label.querySelector('input').dataset.orig);
    label.classList.remove('correct','incorrect','selected');
    if (corr.includes(orig)) label.classList.add('correct');
    if (chosen.includes(orig) && !corr.includes(orig)) label.classList.add('incorrect');
    if (chosen.includes(orig)) label.classList.add('selected');
  });
  feedbackEl.textContent = full ? '✓ Полностью правильно' : '✗ Неправильно';
  feedbackEl.className = 'feedback ' + (full ? 'correct' : 'incorrect');
  feedbackEl.style.display = 'block';
  if (full) score++;
  answered = true;
  questionsAnswered++;
  actionBtn.disabled = false;
}

function proceedToNext(){
  if (currentIndex >= order.length) return;
  const qidx = order[currentIndex];
  const q = currentQuestions[qidx];
  if (isMulti(q) && !answered) { evaluateMulti(qidx); return; }
  if (!isMulti(q) && !answered) return;

  let wasCorrect = false;
  if (isMulti(q)){
    const chosen = (userSelections[qidx] || []).slice().sort((a,b)=>a-b);
    const corr = q.correctAnswers.slice().sort((a,b)=>a-b);
    wasCorrect = JSON.stringify(chosen)===JSON.stringify(corr);
  } else {
    wasCorrect = q.correctAnswers.includes((userSelections[qidx]||[null])[0]);
  }

  if (mode==='mastery' && !wasCorrect){
    const gap = Math.floor(Math.random()*3)+2;
    const insertPos = Math.min(currentIndex+gap, order.length);
    order.splice(insertPos,0,qidx);
  }

  currentIndex++;
  if (currentIndex>=order.length){ showResults(); return; }
  renderCurrent();
}

function showResults(){
  qtext.textContent = `Тест завершён. Результат: ${score} / ${totalQuestionsInTest}`;
  optionsEl.innerHTML = '';
  actionBtn.disabled = true;
}

/* ======= UI handlers ======= */
actionBtn.addEventListener('click', ()=> {
  if (currentIndex === order.length-1 && mode==='single') { showResults(); return; }
  proceedToNext();
});
prevBtn.addEventListener('click', ()=> { if (currentIndex>0){ currentIndex--; renderCurrent(); } });
singleBtn.addEventListener('click', ()=> startSession('single'));
masteryBtn.addEventListener('click', ()=> startSession('mastery'));

/* ======= init ======= */
document.addEventListener('DOMContentLoaded', ()=> {
  startModal.style.display = 'flex';
});
</script>
</body>
</html>
